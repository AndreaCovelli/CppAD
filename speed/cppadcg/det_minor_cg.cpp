/* --------------------------------------------------------------------------
CppAD: C++ Algorithmic Differentiation: Copyright (C) 2003-20 Bradley M. Bell

CppAD is distributed under the terms of the
             Eclipse Public License Version 2.0.

This Source Code may also be made available under the following
Secondary License when the conditions for such availability set forth
in the Eclipse Public License, Version 2.0 are satisfied:
      GNU General Public License, Version 2.0 or later.
---------------------------------------------------------------------------- */
/*
$begin cppad_det_minor_cg.cpp$$
$spell
    typedef
    cppad
    CppAD
    det
    hpp
    const
    bool
    std
$$

$section Cppadcg Speed: Source Generation: Gradient of Determinant by Minor$$

$head Syntax$$
$codei%det_minor_cg(%size%, %optimize%)%$$

$head Purpose$$
Generates C++ source code that computes the derivative of the
determinant of a square matrix.

$head size$$
Is the row and column dimension of the matrix.

$head optimize$$
Should the AD function representing the determinant be optimized
before computing its derivative.

$head det_minor_grad.cpp$$
The source code is written to this file in the current working directory.
It has the following prototype:
$codei%
    template <class Vector>
    void det_minor_grad(const Vector& %x%, const Vector& %y%)
%$$

$subhead x$$
Is the values in the matrix stored in either row or column major order.

$subhead y$$
Is the gradient of the determinant function.

$head Implementation$$
$srccode%cpp% */
# include <cppad/cg/cppadcg.hpp>
# include <cppad/speed/det_by_minor.hpp>

void det_minor_cg(size_t size, bool optimize)
{
    // --------------------------------------------------------------------
    // optimization options: no conditional skips or compare operators
    std::string optimize_options =
        "no_conditional_skip no_compare_op no_print_for_op";
    // -----------------------------------------------------
    // setup

    // object for computing determinant
    typedef CppAD::cg::CG<double>    c_double;
    typedef CppAD::AD<c_double>      ac_double;
    typedef CppAD::vector<c_double>  c_vector;
    typedef CppAD::vector<ac_double> ac_vector;
    CppAD::det_by_minor<ac_double>   ac_det(size);

    size_t nd = 1;           // number of dependent variables in determinant
    size_t nx = size * size; // number of independent variables
    ac_vector   ac_A(nx);    // determinant domain space vector
    ac_vector   ac_detA(nd); // determinant range space vector


    // the AD function object
    CppAD::ADFun<c_double> c_f;

    // do not even record comparison operators

    // ---------------------------------------------------------------------
    // values of independent variables do not matter
    for(size_t i = 0; i < nx; i++)
        ac_A[i] = ac_double( double(i) / double(nx) );

    // declare independent variables without comparison operators
    size_t abort_op_index = 0;
    bool record_compare   = false;
    Independent(ac_A, abort_op_index, record_compare);

    // AD computation of the determinant
    ac_detA[0] = ac_det(ac_A);

    // create function object f : A -> detA
    c_f.Dependent(ac_A, ac_detA);

    if( optimize )
        c_f.optimize(optimize_options);

    // source code generator used for det_minor_grad(x) = d/dx f(x)
    CppAD::cg::CodeHandler<double> code_handler;

    // declare the independent variables in det_minor_grad
    c_vector c_x(nx);
    code_handler.makeVariables(c_x);

    // declare the dependent variables in det_minor_grad
    size_t ny = nd * nx;
    c_vector c_y(ny);

    // evaluate the determinant as a function of c_x
    c_f.Forward(0, c_x);

    // evaluate the gradient using reverse mode
    CppAD::vector<c_double> c_w(nd);
    c_w[0] = c_double(1.0);
    c_y    = c_f.Reverse(1, c_w);

	// Mapping from variables in this program to variables in source_code
	// independent variable = x
	// dependent variable   = y
	// temporary variable   = v
	CppAD::cg::LanguageC<double> langC("double");
	CppAD::cg::LangCDefaultVariableNameGenerator<double> nameGen;

	// generate the source code
	std::ostringstream source_code;
	code_handler.generateCode(source_code, langC, c_y, nameGen);

    // number of temporary variables
	size_t nv = code_handler.getTemporaryVariableCount();

    // wrap the string generated by code_handler into a function
    // y = det_minor_grad(x)
    std::string source_str =
        "template <class Vector>\n"
        "void det_minor_grad(const Vector& x, Vector& y)\n"
        "{\n"
    ;
    source_str += "\tVector v(" + CppAD::to_string(nv) + ");\n";
    source_str += "// Begin code generated by CppADCodeGen\n";
    source_str += source_code.str();
    source_str += "// End code generated by CppADCodeGen\n";
    source_str += "}\n";

    // write source code to det_minor_grad.cpp
    std::fstream fs;
    fs.open("det_minor_grad.cpp", std::fstream::out);
    fs << source_str;
    fs.close();
}
/* %$$
$end
*/
