/* --------------------------------------------------------------------------
CppAD: C++ Algorithmic Differentiation: Copyright (C) 2003-19 Bradley M. Bell

CppAD is distributed under the terms of the
             Eclipse Public License Version 2.0.

This Source Code may also be made available under the following
Secondary License when the conditions for such availability set forth
in the Eclipse Public License, Version 2.0 are satisfied:
      GNU General Public License, Version 2.0 or later.
---------------------------------------------------------------------------- */

$begin CppAD_vector$$
$spell
    rvalues
    thread_alloc
    cppad.hpp
    Bool
    resize
    cout
    endl
    std
    Cpp
    const
    vec
    ostream
    elem
    Iterators
    typename
    iterator
$$


$section The CppAD::vector Template Class$$

$head Syntax$$
$codei%# include <cppad/utility/vector.hpp>
%$$
$codei%# include <cppad/utility/vector_bool.hpp>
%$$

$head Description$$
The include file $code cppad/vector.hpp$$ defines the
vector template class $code CppAD::vector$$.
This is a $cref SimpleVector$$ template class and in addition
it has the features listed below:

$head Include$$
The files
$code cppad/utility/vector.hpp$$ and $code cppad/utility/vector_bool.hpp$$ are
included by $code cppad/cppad.hpp$$.
They can also be included separately with out the rest of the
CppAD include files.

$subhead Deprecated 2019-08-19$$
The file $code cppad/utility/vector.hpp$$
includes the $code cppad/utility/vector_bool.hpp$$
because they used to be one file.
If you want $cref/vectorBool/CppAD_vector/vectorBool/$$,
and not the rest of CppAD, you should include
$code cppad/utility/vector_bool.hpp$$.


$head capacity$$
If $icode x$$ is a $codei%CppAD::vector<%Scalar%>%$$,
and $icode cap$$ is a $code size_t$$ object,
$codei%
    %cap% = %x%.capacity()
%$$
set $icode cap$$ to the number of $icode Scalar$$ objects that
could fit in the memory currently allocated for $icode x$$.
Note that
$codei%
    %x%.size() <= %x%.capacity()
%$$

$head swap$$
If $icode x$$ and $icode y$$ are
$codei%CppAD::vector<%Scalar%>%$$ objects,
$codei%
    %y%.swap(%x%)
%$$
exchanges the contents of $icode x$$ and $icode y$$.
For example $cref/x.data()/CppAD_vector/data/$$ after the $code swap$$
is equal to $icode%y%.data()%$$ before $code swap$$.


$head Assignment$$
If $icode x$$ and $icode y$$ are
$codei%CppAD::vector<%Scalar%>%$$ objects,
$codei%
    %y% = %x%
%$$
has all the properties listed for a
$cref/simple vector assignment/SimpleVector/Assignment/$$
plus the following:

$subhead Check Size$$
The $code CppAD::vector$$ template class will check that
the size of $icode y$$ is either zero or the size of $icode x$$
before doing the assignment.
If this is not the case, and $code NDEBUG$$ is not defined,
$code CppAD::vector$$ will use
$cref ErrorHandler$$
to generate an appropriate error report.
Requiring the sizes to agree checks that memory will not need to
be allocated to do the assignment (except when $icode x$$ is empty).
Allowing for assignment to a vector with size zero makes the following
code work:
$codei%
    CppAD::vector<%Scalar%> %y%;
    %y% = %x%;
%$$

$subhead Return Reference$$
A reference to the vector $icode y$$ is returned.
An example use of this reference is in multiple assignments of the form
$codei%
    %z% = %y% = %x%
%$$

$subhead Move Semantics$$
If the C++ compiler supports move semantic rvalues using the $code &&$$
syntax, then it will be used during the vector assignment statement.
This means that return values and other temporaries are not be copied,
but rather pointers are transferred.

$head Element Access$$
If $icode x$$ is a $codei%CppAD::vector<%Scalar%>%$$ object
and $icode i$$ has type $code size_t$$,
$codei%
    %x%[%i%]
%$$
has all the properties listed for a
$cref/simple vector element access/SimpleVector/Element Access/$$
plus the following:

$subhead i$$
This operation is defined for any $icode i$$
that has a conversion to $code size_t$$.
The object $icode%x%[%i%]%$$ has type $icode Scalar$$
(is not possibly a different type that can be converted to $icode Scalar$$).

$subhead Error Checking$$
If $icode i$$ is not less than the size of the $icode x$$,
and $code NDEBUUG$$ is not defined,
$code CppAD::vector$$ will use
$cref ErrorHandler$$
to generate an appropriate error report.

$head push_back$$
If $icode x$$ is a $codei%CppAD::vector<%Scalar%>%$$ object
with size equal to $icode n$$ and
$icode s$$ has type $icode Scalar$$,
$codei%
    %x%.push_back(%s%)
%$$
extends the vector $icode x$$ so that its new size is $icode n$$ plus one
and $icode%x%[%n%]%$$ is equal to $icode s$$
(equal in the sense of the $icode Scalar$$ assignment operator).

$head push_vector$$
If $icode x$$ is a $codei%CppAD::vector<%Scalar%>%$$ object
with size equal to $icode n$$ and
$icode v$$ is a $cref/simple vector/SimpleVector/$$
with elements of type $icode Scalar$$ and size $icode m$$,
$codei%
    %x%.push_vector(%v%)
%$$
extends the vector $icode x$$ so that its new size is $icode%n%+%m%$$
and $icode%x%[%n% + %i%]%$$ is equal to $icode%v%[%i%]%$$
for $icode%i = 1 , ... , m-1%$$
(equal in the sense of the $icode Scalar$$ assignment operator).

$head Output$$
If $icode x$$ is a $codei%CppAD::vector<%Scalar%>%$$ object
and $icode os$$ is an $code std::ostream$$,
and the operation
$codei%
    %os% << %x%
%$$
will output the vector $icode x$$ to the standard
output stream $icode os$$.
The elements of $icode x$$ are enclosed at the beginning by a
$code {$$ character,
they are separated by $code ,$$ characters,
and they are enclosed at the end by $code }$$ character.
It is assumed by this operation that if $icode e$$
is an object with type $icode Scalar$$,
$codei%
    %os% << %e%
%$$
will output the value $icode e$$ to the standard
output stream $icode os$$.

$head resize$$
The call $icode%x%.resize(%n%)%$$ set the size of $icode x$$ equal to
$icode n$$.
If $icode%n% <= %x%.capacity()%$$,
no memory is freed or allocated, the capacity of $icode x$$ does not change,
and the data in $icode x$$ is preserved.
If $icode%n% > %x%.capacity()%$$,
new memory is allocated and the data in $icode x$$ is lost
(not copied to the new memory location).

$head clear$$
All memory allocated for the vector is freed
and both its size and capacity are set to zero.
This can be useful when using very large vectors
and when checking for memory leaks (and there are global vectors)
see the $cref/memory/CppAD_vector/Memory and Parallel Mode/$$ discussion.

$head data$$
If $icode x$$ is a $codei%CppAD::vector<%Scalar%>%$$ object
$codei%
    %x%.data()
%$$
returns a pointer to a $icode Scalar$$ object such that for
$codei%0 <= %i% < %x%.size()%$$,
$icode%x%[%i%]%$$ and $icode%x%.data()[%i%]%$$
are the same $icode Scalar$$ object.
If $icode x$$ is $code const$$, the pointer is $code const$$.
If $icode%x%.capacity()%$$ is zero, the value of the pointer is not defined.
The pointer may no longer be valid after the following operations on
$icode x$$:
its destructor,
$code clear$$,
$code resize$$,
$code push_back$$,
$code push_vector$$,
assignment to another vector when original size of $icode x$$ is zero.

$head Iterators$$

$subhead Syntax$$
$codei%typename CppAD::vector<%Scalar%>::iterator
%$$
$codei%typename CppAD::vector<%Scalar%>::const_iterator
%$$
$icode%vec%.begin()
%$$
$icode%vec%.end()
%$$

$subhead iterator$$
is a random access iterator type for non $code const$$ objects.

$subhead const_iterator$$
is a random access iterator type for a $code const$$ objects.

$subhead begin$$
is a $code const_iterator$$ ($code iterator$$)
depending on if $icode vec$$ is  $code const$$
(not $code const$$) corresponding to the first element
of the vector.

$subhead end$$
is a $code const_iterator$$ ($code iterator$$)
depending on if $icode vec$$ is  $code const$$
(not $code const$$) corresponding to beyond the last element
of the vector.

$subhead Error Checking$$
Each element access does an error check similar to the
$cref/error checking/CppAD_vector/Element Access/Error Checking/$$ above.
The error handler will also be called,
if $code NDEBUG$$ is not defined and
a comparison operator (e.g. $code >$$) is used between
two iterators that correspond to different vectors.


$head vectorBool$$
The file $code <cppad/vector.hpp>$$ also defines the class
$code CppAD::vectorBool$$.
This has the same specifications as $code CppAD::vector<bool>$$
with the following exceptions:

$subhead Memory$$
The class $code vectorBool$$ conserves on memory
(on the other hand, $code CppAD::vector<bool>$$ is expected to be faster
than $code vectorBool$$).

$subhead bit_per_unit$$
The static function call
$codei%
    %s% = vectorBool::bit_per_unit()
%$$
returns the $code size_t$$ value $icode s$$
which is equal to the number of boolean values (bits) that are
packed into one operational unit.
For example, a logical $code or$$
acts on this many boolean values with one operation.

$subhead data$$
The $cref/data/CppAD_vector/data/$$ function is not supported by
$code vectorBool$$.

$subhead Iterators$$
The $cref/Iterators/CppAD_vector/Iterators/$$ are not supported by
$code vectorBool$$.

$subhead Output$$
The $code CppAD::vectorBool$$ output operator
prints each boolean value as
a $code 0$$ for false,
a $code 1$$ for true,
and does not print any other output; i.e.,
the vector is written a long sequence of zeros and ones with no
surrounding $code {$$, $code }$$ and with no separating commas or spaces.

$subhead Element Type$$
If $icode x$$ has type $code vectorBool$$
and $icode i$$ has type $code size_t$$,
the element access value $icode%x%[%i%]%$$ has an unspecified type,
referred to here as $icode elementType$$, that supports the following
operations:

$list number$$
$icode elementType$$ can be converted to $code bool$$; e.g.
the following syntax is supported:
$codei%
    static_cast<bool>( %x%[%i%] )
%$$

$lnext
$icode elementType$$ supports the assignment operator $code =$$ where the
right hand side is a $code bool$$ or an $icode elementType$$ object; e.g.,
if $icode y$$ has type $code bool$$, the following syntax is supported:
$codei%
    %x%[%i%] = %y%
%$$

$lnext
The result of an assignment to an $icode elementType$$
also has type $icode elementType$$.
Thus, if $icode z$$ has type $code bool$$, the following syntax is supported:
$codei%
    %z% = %x%[%i%] = %y%
%$$
$lend

$head Memory and Parallel Mode$$
These vectors use the multi-threaded fast memory allocator
$cref thread_alloc$$:

$list number$$
The routine $cref/parallel_setup/ta_parallel_setup/$$ must
be called before these vectors can be used
$cref/in parallel/ta_in_parallel/$$.
$lnext
Using these vectors affects the amount of memory
$cref/in_use/ta_inuse/$$ and $cref/available/ta_available/$$.
$lnext
Calling $cref/clear/CppAD_vector/clear/$$,
makes the corresponding memory available (though $code thread_alloc$$)
to the current thread.
$lnext
Available memory
can then be completely freed using $cref/free_available/ta_free_available/$$.
$lend

$head Example$$
$children%
    example/utility/cppad_vector.cpp%
    example/utility/vector_bool.cpp
%$$
The files
$cref cppad_vector.cpp$$ and
$cref vector_bool.cpp$$ each
contain an example and test of this template class.
They return true if they succeed and false otherwise.

$head Exercise$$
Create and run a program that contains the following code:
$codep
    CppAD::vector<double> x(3);
    size_t i;
    for(i = 0; i < 3; i++)
        x[i] = 4. - i;
    std::cout << "x = " << x << std::endl;
$$

$end
