// BEGIN SHORT COPYRIGHT
/* -----------------------------------------------------------------------
CppAD: C++ Algorithm Differentiation: Copyright (C) 2003-05 Bradley M. Bell

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
------------------------------------------------------------------------ */
// END SHORT COPYRIGHT

$begin TheoryExam$$

$section A Demonstration of Forward and Reverse Mode$$

A procedural representation of a function 
is a step by step evaluation method; i.e.,
given a set of independent variable values (a point in the domain)
the procedure computes a set of dependent variables (a point in the range).

Automatic differentiation starts with an procedural representation
of a function and generates an procedural representation of its 
partial derivatives. 

Forward mode calculates the partial derivative of all the dependent
variables with respect to one of the independent variables with in a 
small multiple (independent of the number of variables) 
of the computational load required to evaluate the original function.


Reverse mode calculates the partial derivative of one of the dependent
variables with respect to all of the independent variables with in a 
small multiple (independent of the number of variables) 
of the computational load required to evaluate the original function.

In this section we demonstrate how this works 
for an example case. 
It is organized as follows:

$list number$$
$tref TheoryExamFun$$
$lnext
$tref TheoryExamProc$$
$lnext
$tref TheoryExamBinary$$
$lnext
$tref TheoryExamEval$$
$lnext
$tref TheoryExamFor$$
$lnext
$tref TheoryRevNotation$$
$lnext
$tref TheoryExamRev$$
$lend
 


$children%
	omh\TheoryExamList.omh
%$$


$end
